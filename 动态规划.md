# 动态规划

## 动态规划理论基础

### 动态规划刷题大纲

![](https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%80%BB%E7%BB%93%E5%A4%A7%E7%BA%B21.jpg)

### [#](https://www.programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)什么是动态规划

动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。

所以动态规划中每一个状态一定是由上一个状态推导出来的， **这一点就区分于贪心** ，贪心没有状态推导，而是从局部直接选最优的，

在[关于贪心算法，你该了解这些！ **(opens new window)**](https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)中我举了一个背包问题的例子。

例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。 **每件物品只能用一次** ，求解将哪些物品装入背包里物品价值总和最大。

动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。

但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。

所以贪心解决不了动态规划的问题。

 **其实大家也不用死扣动规和贪心的理论区别，后面做做题目自然就知道了** 。

而且很多讲解动态规划的文章都会讲最优子结构啊和重叠子问题啊这些，这些东西都是教科书的上定义，晦涩难懂而且不实用。

大家知道动规是由前一个状态推导出来的，而贪心是局部直接选最优的，对于刷题来说就够用了。

上述提到的背包问题，后序会详细讲解。

### [#](https://www.programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4)动态规划的解题步骤

做动规题目的时候，很多同学会陷入一个误区，就是以为把状态转移公式背下来，照葫芦画瓢改改，就开始写代码，甚至把题目AC之后，都不太清楚dp[i]表示的是什么。

 **这就是一种朦胧的状态，然后就把题给过了，遇到稍稍难一点的，可能直接就不会了，然后看题解，然后继续照葫芦画瓢陷入这种恶性循环中** 。

状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。

**对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！**

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

一些同学可能想为什么要先确定递推公式，然后在考虑初始化呢？

**因为一些情况是递推公式决定了dp数组要如何初始化！**

后面的讲解中我都是围绕着这五点来进行讲解。

可能刷过动态规划题目的同学可能都知道递推公式的重要性，感觉确定了递推公式这道题目就解出来了。

其实 确定递推公式 仅仅是解题里的一步而已！

一些同学知道递推公式，但搞不清楚dp数组应该如何初始化，或者正确的遍历顺序，以至于记下来公式，但写的程序怎么改都通过不了。

后序的讲解的大家就会慢慢感受到这五步的重要性了。

### [#](https://www.programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95debug)动态规划应该如何debug

相信动规的题目，很大部分同学都是这样做的。

看一下题解，感觉看懂了，然后照葫芦画瓢，如果能正好画对了，万事大吉，一旦要是没通过，就怎么改都通过不了，对 dp数组的初始化，递推公式，遍历顺序，处于一种黑盒的理解状态。

写动规题目，代码出问题很正常！

**找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！**

一些同学对于dp的学习是黑盒的状态，就是不清楚dp数组的含义，不懂为什么这么初始化，递推公式背下来了，遍历顺序靠习惯就是这么写的，然后一鼓作气写出代码，如果代码能通过万事大吉，通过不了的话就凭感觉改一改。

这是一个很不好的习惯！

 **做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果** 。

然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。

如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。

如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

 **这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了** 。

这也是我为什么在动规五步曲里强调推导dp数组的重要性。

举个例子哈：在「代码随想录」刷题小分队微信群里，一些录友可能代码通过不了，会把代码抛到讨论群里问：我这里代码都已经和题解一模一样了，为什么通过不了呢？

发出这样的问题之前，其实可以自己先思考这三个问题：

* 这道题目我举例推导状态转移公式了么？
* 我打印dp数组的日志了么？
* 打印出来了dp数组和我想的一样么？

 **如果这灵魂三问自己都做到了，基本上这道题目也就解决了** ，或者更清晰的知道自己究竟是哪一点不明白，是状态转移不明白，还是实现代码不知道该怎么写，还是不理解遍历dp数组的顺序。

然后在问问题，目的性就很强了，群里的小伙伴也可以快速知道提问者的疑惑了。

**注意这里不是说不让大家问问题哈， 而是说问问题之前要有自己的思考，问题要问到点子上！**

**大家工作之后就会发现，特别是大厂，问问题是一个专业活，是的，问问题也要体现出专业！**

如果问同事很不专业的问题，同事们会懒的回答，领导也会认为你缺乏思考能力，这对职场发展是很不利的。

所以大家在刷题的时候，就锻炼自己养成专业提问的好习惯。

### [#](https://www.programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E6%80%BB%E7%BB%93)总结

这一篇是动态规划的整体概述，讲解了什么是动态规划，动态规划的解题步骤，以及如何debug。

动态规划是一个很大的领域，今天这一篇讲解的内容是整个动态规划系列中都会使用到的一些理论基础。

在后序讲解中针对某一具体问题，还会讲解其对应的理论基础，例如背包问题中的01背包，leetcode上的题目都是01背包的应用，而没有纯01背包的问题，那么就需要在把对应的理论知识讲解一下。

大家会发现，我讲解的理论基础并不是教科书上各种动态规划的定义，错综复杂的公式。

这里理论基础篇已经是非常偏实用的了，每个知识点都是在解题实战中非常有用的内容，大家要重视起来哈。

## 刷题

[509. 斐波那契数 - 力扣（Leetcode）](https://leetcode.cn/problems/fibonacci-number/)

```cpp
class Solution {
public:
    vector<int> fibNum;
    int fib(int n) {
        fibNum.push_back(0);
        fibNum.push_back(1);
        for (int i=2;i<=n;i++)
        {
            fibNum.push_back(fibNum[i-1]+fibNum[i-2]);
        }
        return fibNum[n];
    }
  
};

对比一下卡哥写的代码，我的代码可能有一些问题吧，但是这样还是可以接收
class Solution {
public:
    int fib(int N) {
        if (N <= 1) return N;
        vector<int> dp(N + 1);
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= N; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[N];
    }
};
```

用动态规划进行求解，这是一种典型的以空间去换时间的方式，这样还是非常优秀的。

[70. 爬楼梯 - 力扣（Leetcode）](https://leetcode.cn/problems/climbing-stairs/description/)

```cpp
这个问题还是已经反复做过无数遍了，这里我直接写出来就没问题了
1.dp数组的含义，dp[i]代表到达第i个台阶有多少种方式
2.确定递推公式 dp[i]=dp[i-1]+dp[i-2]
3.如何初始化 dp[0]=1 dp[1]=1
4.确定遍历顺序，一维数组，哪里来的顺序，直接遍历就行
5.自行推导尝试。

#include<iostream>
#include <vector>
using namespace std;
class Solution {
public:
    vector<int> dp;
    int climbStairs(int n) {
        dp.push_back(1);
        dp.push_back(1);
        for(int i=2;i<=n;i++)
        {
            dp.push_back(dp[i-1]+dp[i-2]);
        }
        return dp[n];
    }
};
```

这里可以轻松求解出来答案，也就没有更多的问题了。

[746. 使用最小花费爬楼梯 - 力扣（Leetcode）](https://leetcode.cn/problems/min-cost-climbing-stairs/)

```cpp
1.确定dp数组的含义，这里很简单就可以确定出其含义，dp[i]就是到达第i级的最少消费
2.确定递推公式，dp[i]=min{dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]}
3.如何初始化dp[0]=0 dp[1]=0 
4.确定遍历顺序，一维的不用遍历
5.自行推导尝试，这里也不用尝试。
解决方法已经熟练到不行了，这个就这样美好的通过了。

#include<iostream>
#include <vector>
using namespace std;
class Solution {
public:
    vector<int> dp;
    int minCostClimbingStairs(vector<int>& cost) {
        dp.push_back(0);
        dp.push_back(0);
        for(int i=2;i<=cost.size();i++)
        {
            dp.push_back(min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]));
        }
        return dp[cost.size()];
    }
};
```

[62. 不同路径 - 力扣（Leetcode）](https://leetcode.cn/problems/unique-paths/)

```cpp
这里其实可以看到其实是一种深度优先搜索的思路，但是我们学习了动态规划，就可以使用动态规划的方式进行求解。
1.确定dp数组的含义，dp[i][j]代表到达i,j格子的时候的路线的数量。
2.确定递推公式，由于机器人只能向右或者向下一步，那么我们可以知道dp[i][j]=dp[i-1][j]+dp[i][j-1]
3.初始化，首先到达[0][0]位置的方式为1，之后的[0][1]位置的方式为1，到达[1][0]位置的方式为1
4.确定遍历顺序，按照行或者列遍历都可以，那么我们就按照行进行遍历了
5.自行推导尝试
出现了一些小问题，这里的问题在于初始化的问题，还是需要历练啊

class Solution {
public:
    vector<vector<int>> dp;
    int uniquePaths(int m, int n) {
        dp=vector<vector<int>>(100,vector<int>(100,0));
        for(int i=0;i<n;i++)
        {
            dp[0][i]=1;
        }
        for(int i=0;i<m;i++)
        {
            dp[i][0]=1;
        }
        for(int i=1;i<m;i++)
        {
            for(int j=1;j<n;j++){
                dp[i][j]=dp[i][j-1]+dp[i-1][j];
            }
        }
        return dp[m-1][n-1];
    }
};
```

[63. 不同路径 II - 力扣（Leetcode）](https://leetcode.cn/problems/unique-paths-ii/)

```cpp
这里本质上其实跟上面那个题是一样的逻辑，这里直接使用卡哥得代码放到这里了，我就不写了
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
	if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) //如果在起点或终点出现了障碍，直接返回0
            return 0;
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 1) continue;
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

[343. 整数拆分 - 力扣（Leetcode）](https://leetcode.cn/problems/integer-break/)

```cpp
1.首先确认dp数组的含义 dp[i]代表正整数i拆分成的两个整数的乘积最大值。
2.确认递推公式 首先第i项可以拆成dp[i-j] * j 这里采用遍历的方式就可以进行，或者就可以拆成 j*(i-j) 这样就确认了方法，同时取两个值里面的最大值就可以求解了。
3.如何初始化 首先可以确定的是dp[0]=0 dp[1]=0 dp[2]=1 dp[3]=2 ... 剩下的可以利用递推公式进行计算了
4.确定遍历顺序 不需要确定 就只有一个未知数
5.自行推导

下面的代码还是一遍通过了，当然这个题还是非常简单的（看过代码随想录）

class Solution {
public:

    int integerBreak(int n) {
        //init
        vector<int> dp(60,0);
        dp[0]=0;
        dp[1]=0;
        dp[2]=1;

        //calculate
        //i代表dp的索引
        //j代表进行遍历使用的变量
        for (int i =3;i<=n;i++)
        {
            for(int j=0;j<=i;j++)
            {
                int tmp1=j*(i-j);
                int tmp2=j*dp[i-j];
                //返回三者之间的最大值
                dp[i]=dp[i]>(tmp1>tmp2?tmp1:tmp2)?dp[i]:(tmp1>tmp2?tmp1:tmp2);  
            }
        }
        return dp[n];
    }
};


卡哥说这里也可以使用贪心，代码如下：
class Solution {
public:
    int integerBreak(int n) {
        if (n == 2) return 1;
        if (n == 3) return 2;
        if (n == 4) return 4;
        int result = 1;
        while (n > 4) {
            result *= 3;
            n -= 3;
        }
        result *= n;
        return result;
    }
};
```

[※96. 不同的二叉搜索树 - 力扣（Leetcode）](https://leetcode.cn/problems/unique-binary-search-trees/)

```cpp
1.确定dp数组的含义  dp[i]的含义是当有i个节点的时候有多少种二叉搜索树
2.确定递推公式  这里的思路也是不太好想到的结果，这个题相对困难，这里先放到后面再回来复习的时候进行
3.初始化 这里也不用想 dp[0]=0 dp[1]=1 dp[2]=2 
4.确定遍历顺序
5.自行推导尝试


```
